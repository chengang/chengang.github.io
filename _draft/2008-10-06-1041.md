---
title: 常用字符集编码的概要特性——转自头儿Blog
date: 2008-10-06T11:10:56+00:00

tags:
  - 字符集问题
---
**ASCII**

ASCII码是7位编码，编码范围是0×00-0×7F。ASCII字符集包括英文字母、阿拉伯数字和标点符号等字符。其中0×00-0×20和0×7F共33个控制字符。

只支持ASCII码的系统会忽略每个字节的最高位，只认为低7位是有效位。HZ字符编码就是早期为了在只支持7位ASCII系统中传输中文而设计的编码。早期很多邮件系统也只支持ASCII编码，为了传输中文邮件必须使用BASE64或者其他编码方式。

**GB2312**

GB2312是基于区位码设计的，区位码把编码表分为94个区，每个区对应94个位，每个字符的区号和位号组合起来就是该汉字的区位码。区位码一般用10进制数来表示，如1601就表示16区1位，对应的字符是“啊”。在区位码的区号和位号上分别加上0xA0就得到了GB2312编码。

区位码中01-09区是符号、数字区，16-87区是汉字区，10-15和88-94是未定义的空白区。它将收录的汉字分成两级：第一级是常用汉字计3755个，置于16-55区，按汉语拼音字母/笔形顺序排列；第二级汉字是次常用汉字计3008个，置于56-87区，按部首/笔画顺序排列。一级汉字是按照拼音排序的，这个就可以得到某个拼音在一级汉字区位中的范围，很多根据汉字可以得到拼音的程序就是根据这个原理编写的。

GB2312字符集中除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。可以用繁体汉字测试某些系统是不是只支持GB2312编码。

GB2312的编码范围是0xA1A1-0×7E7E，去掉未定义的区域之后可以理解为实际编码范围是0xA1A1-0xF7FE。

EUC-CN可以理解为GB2312的别名，和GB2312完全相同。

> 区位码更应该认为是字符集的定义，定义了所收录的字符和字符位置，而GB2312及EUC-CN是实际计算机环境中支持这种字符集的编码。HZ和ISO-2022-CN是对应区位码字符集的另外两种编码，都是用7位编码空间来支持汉字。区位码和GB2312编码的关系有点像 Unicode和UTF-8。

**GBK**

GBK编码是GB2312编码的超集，向下完全兼容GB2312，同时GBK收录了Unicode基本多文种平面中的所有CJK汉字。同 GB2312一样，GBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的汉字部首符号、竖排标点符号等字符。

GBK的整体编码范围是为0×8140-0xFEFE，不包括低字节是0×7F的组合。高字节范围是0×81-0xFE，低字节范围是0×40-7E和0×80-0xFE。

低字节是0×40-0×7E的GBK字符有一定特殊性，因为这些字符占用了ASCII码的位置，这样会给一些系统带来麻烦。

> 有些系统中用0×40-0×7E中的字符（如“|”）做特殊符号，在定位这些符号时又没有判断这些符号是不是属于某个 GBK字符的低字节，这样就会造成错误判断。在支持GB2312的环境下就不存在这个问题。需要注意的是支持GBK的环境中小于0×80的某个字节未必就是ASCII符号；另外就是最好选用小于0×40的ASCII符号做一些特殊符号，这样就可以快速定位，且不用担心是某个汉字的另一半。Big5编码中也存在相应问题。

CP936和GBK的有些许差别，绝大多数情况下可以把CP936当作GBK的别名。

**GB18030**

GB18030编码向下兼容GBK和GB2312，兼容的含义是不仅字符兼容，而且相同字符的编码也相同。GB18030收录了所有Unicode3.1中的字符，包括中国少数民族字符，GBK不支持的韩文字符等等，也可以说是世界大多民族的文字符号都被收录在内。

GBK和GB2312都是双字节等宽编码，如果算上和ASCII兼容所支持的单字节，也可以理解为是单字节和双字节混合的变长编码。GB18030编码是变长编码，有单字节、双字节和四字节三种方式。

GB18030的单字节编码范围是0×00-0×7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0×81-0xFE，低字节的编码范围是0×40-0×7E和0×80-FE；四字节编码中第一、三字节的编码范围是0×81-0xFE，二、四字节是0×30-0×39。

Windows中CP936代码页使用0×80来表示欧元符号，而在GB18030编码中没有使用0×80编码位，用其他位置来表示欧元符号。这可以理解为是GB18030向下兼容性上的一点小问题；也可以理解为0×80是CP936对GBK的扩展，而GB18030只是和GBK兼容良好。

**BIG5**

Big5是双字节编码，高字节编码范围是0×81-0xFE，低字节编码范围是0×40-0×7E和0xA1-0xFE。和GBK相比，少了低字节是0×80-0xA0的组合。0×8140-0xA0FE是保留区域，用于用户造字区。

Big5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。GBK收录的日文假名字符、俄文字符Big5也没有收录。因为 Big5当中收录的字符有限，因此有很多在Big5基础上扩展的编码，如倚天中文系统。Windows系统上使用的代码页CP950也可以理解为是对 Big5的扩展，在Big5的基础上增加了7个汉字和一些符号。Big5编码对应的字符集是GBK字符集的子集，也就是说Big5收录的字符是GBK收录字符的一部分，但相同字符的编码不同。

因为Big5也占用了ASCII的编码空间（低字节所使用的0×40-0×7E），所以Big5编码在一些环境下存在和GBK编码相同的问题，即低字节范围为0×40-0×7E的字符有可能会被误处理，尤其是低字节是0×5C（”/”）和0×7C（”|”）的字符。可以参考**GBK**一节相应说明。

尽管有些区别，大多数情况下可以把CP950当作Big5的别名。

**ISO-8859-1**

ISO-8859-1编码是单字节编码，向下兼容ASCII，其编码范围是0×00-0xFF，0×00-0×7F之间完全和ASCII一致，0×80-0×9F之间是控制字符，0xA0-0xFF之间是文字符号。

ISO-8859-1收录的字符除ASCII收录的字符外，还包括西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号。欧元符号出现的比较晚，没有被收录在ISO-8859-1当中。

因为ISO-8859-1编码范围使用了单字节内的所有空间，在支持ISO-8859-1的系统中传输和存储其他任何编码的字节流都不会被抛弃。换言之，把其他任何编码的字节流当作ISO-8859-1编码看待都没有问题。这是个很重要的特性，[MySQL](http://www.mysql.com/)数据库默认编码是Latin1就是利用了这个特性。ASCII编码是一个7位的容器，ISO-8859-1编码是一个8位的容器。

Latin1是ISO-8859-1的别名，有些环境下写作Latin-1。

**UCS-2和UTF-16**

[Unicode](http://www.unicode.org/)组织和[ISO](http://www.iso.org/)组织都试图定义一个超大字符集，目的是要涵盖所有语言使用的字符以及其他学科使用的一些特殊符号，这个字符集就是通用字符集（UCS，Universal Character Set）。这两个组织经过协调，虽然在各自发展，但定义的字符位置是完全一致的。ISO相应的标准是ISO 10646。Unicode和ISO 10646都在不断的发展过程中，所以会有不同的版本号来标明不同的发展阶段，每个Unicode版本号都能找到相对应的ISO 10646版本号。

ISO 10646标准定义了一个31位的字符集。前两个字节的位置（0×0000-0xFFFD）被称为基本多语言面（Basic Multilingual Plane, BMP），超出两个字节的范围称作辅助语言面。BMP基本包括了所有语言中绝大多数字符，所以只要支持BMP就可以支持绝大多数场合下的应用。Unicode 3.0对应的字符集在BMP范围内。

UCS字符集为每个字符分配了一个位置，通常用“U”再加上某个字符在UCS中位置的16进制数作为这个字符的UCS表示，例如“U+0041”表示字符“A”。UCS字符U+0000到U+00FF与ISO-8859-1完全一致。

UCS-2、UTF-16是UCS字符集（或者说是Unicode字符集）实际应用中的具体编码方式。UCS-2是两个字节的等宽编码，因为只是使用了两个字节的编码空间，所以只能对BMP中的字符做编码。UTF-16是变长编码，用两个字节对BMP内的字符编码，用4个字节对超出BMP范围的辅助平面内的字符作编码。

<span>UCS-2不同于GBK和Big5，它是真正的等宽编码，每个字符都使用两个字节，这个特性在字符串截断和字符数计算时非常方便。</span>

UTF-16是UCS-2的超集，UTF-16编码的两字节编码方式完全和UCS-2相同，也就是说在BMP的框架内UCS-2完全等同与UTF-16。实际情况当中常常把UCS-16当作UCS-2的别名。

UCS-2和UTF-16在存储和传输时会使用两种不同的字节序，分别是<span>big endian和little endian（大尾和小尾）。例如“啊”（U+554A）用big endian表示就是0×554A，用little endian表示就是0×4A55。UCS-2和UTF-16默认的字节序是big endian方式。在传输过程中为了说明字节序需要在字节流前加上BOM（Byte order Mark），0xFEFF表示是big endian，0xFFFE表示是little endian。UCS-2BE、UCS-2LE是实际应用中使用的编码名称，对应着big endian和little endian，UTF-16BE、UTF-16LE也是如此。因为默认是BE字节序，所以可以把UCS-2当做是UCS-2BE的别名。</span>

> <span>在UCS编码中有一个叫做“ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是U+FEFF，是个没有实际意义的字符。UCS规范建议我们在传输字节流前，先传输字符“ZERO WIDTH NO-BREAK SPACE”，如果传输的ZERO WIDTH NO-BREAK SPACE是0xFEFF就说明是big endian，反之就是little endian。</span>

<span>UCS-2和UTF-16也可以理解为和ASCII以及ISO-8859-1兼容，在ASCII编码或者ISO-8859-1编码的每个字节前加上0×00，就得到相应字符的UCS-2编码。</span>

<span>UCS-2和UTF-16中会使用0×00作为某个字符编码的一部分，某些系统会把0×00当作字符串结束的标志，在处理UCS-2或UTF-16编码时会出现问题。</span>

**UTF-8**

UTF-8是UCS字符集的另一种编码方式，UTF-16的每个单元是两个字节（16位），而UTF-8的每个单元是一个字节（8位）。UTF-16中用一个或两个双字节表示一个字符，UTF-8中用一个或几个单字节表示一个字符。

可以认为UTF-8编码是根据一定规律从UCS-2转换得到的，从UCS-2到UTF-8之间有以下转换关系：<table border=1> 

</table> 

例如“啊”字的UCS-2编码是0×554A，对应的二进制是**0101 0101 0100 1010**，转成UTF-8编码之后的二进制是1110 **0101** 10 **010101** 10 **001010**，对应的十六进制是0xE5958A。

> UCS-4也是一种UCS字符集的编码方式，是使用4个字节的等宽编码，可以用UCS-4来表示BMP之外的辅助面字符。 UCS-2中每两个字节前再加上0×0000就得到了BMP字符的UCS-4编码。从UCS-4到UTF-8也存在转换关系，根据这种转换关系，UTF- 8最多可以使用六个字节来编码UCS-4。

根据UTF-8的生成规律和UCS字符集的特性，可以看到UTF-8具有的特性：

  1. UTF-8完全和ASCII兼容，也就是说ASCII对应的字符在UTF-8中和ASCII编码完全一致。范围在0×00-0×7F之内的字符一定是ASCII字符，不可能是其他字符的一部分。GBK和Big5都存在的缺陷在UTF-8中是不存在的。 
      * 大于U+007F的UCS字符，在UTF-8编码中至少是两个字节。 
          * UTF-8中的每个字符编码的首字节总在0×00-0xFD之间（不考虑UCS-4支持的情况，首字节在0×00-0xEF之间）。根据首字节就可以判断之后连续几个字节。 
              * 非首字节的其他字节都在0×80-0xBF之间；0xFE和0xFF在UTF-8中没有被用到。 
                  * GBK编码中的汉字字符都在UCS-2中的范围都在U+0800 &#8211; U+FFFF之间，所以每个GBK编码中的汉字字符的UTF-8编码都是3个字节。但GBK中包含的其他字符的UTF-8编码就不一定是3个字节了，如GBK中的俄文字符。</ol> 
                在UTF-8的编码的传输过程中即使丢掉一个字节，根据编码规律也很容易定位丢掉的位置，不会影响到其他字符。在其他双字节编码中，一旦损失一个字节，就会影响到此字节之后的所有字符。从这点可以看出UTF-8编码非常适合作为传输编码。
