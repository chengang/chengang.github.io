---
id: 4496
title: Rust官方指南摘抄（五）模式匹配
date: 2015-01-05T16:11:18+00:00
author: chen
layout: post
guid: http://blog.yikuyiku.com/?p=4496
permalink: /4496.html
categories:
  - 备忘
  - 扯淡
tags:
  - given
  - Match
  - ref
  - rust
  - 入门
  - 教程
  - 模式匹配
  - 正则
---
Rust官方指南摘抄系列内容如下：
  
[（一）语法基础](http://blog.yikuyiku.com/?p=4442 "Rust官方指南摘抄（一）语法基础")
  
[（二）猜数游戏](http://blog.yikuyiku.com/?p=4460 "Rust官方指南摘抄（二）猜数游戏")
  
[（三）模块、测试和宏](http://blog.yikuyiku.com/?p=4478 "Rust官方指南摘抄（三）模块、测试和宏")
  
[（四）指针](http://blog.yikuyiku.com/?p=4485 "Rust官方指南摘抄（四）指针")
  
[（五）模式匹配](http://blog.yikuyiku.com/?p=4496 "Rust官方指南摘抄（五）模式匹配")
  
[（六）方法语法、泛型和抽象方法](http://blog.yikuyiku.com/?p=4500 "Rust官方指南摘抄（六）方法语法、泛型和抽象方法")
  
[（七）闭包和迭代器](http://blog.yikuyiku.com/?p=4508 "Rust官方指南摘抄（七）闭包和迭代器")
  
[（八）并发任务](http://blog.yikuyiku.com/?p=4510 "Rust官方指南摘抄（八）并发任务")

Rust里面的match有点类似Perl里面的given，玩法真的很多样。

1、最基本的。下划线表示其它所有情况。

<pre>let x = 1i;

match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
}
</pre>

2、合并两种情况。

<pre>let x = 1i;

match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
}
</pre>

3、范围。

<pre>let x = 1i;

match x {
    1 ... 5 => println!("one through five"),
    _ => println!("anything"),
}
</pre>

4、捕获。

<pre>let x = 1i;

match x {
    y @ 1 ... 5 => println!("got {}", y),
    _ => println!("anything"),
}
</pre>

5、面对包含可变值的枚举类型可以用..来判断有没有值。

<pre>enum OptionalInt {
    Value(int),
    Missing,
}

let x = Value(5i);

match x {
    Value(..) => println!("Got an int!"),
    Missing   => println!("No such luck."),
}

</pre>

6、支持内嵌if。

<pre>enum OptionalInt {
    Value(int),
    Missing,
}

let x = Value(5i);

match x {
    Value(x) if x > 5 => println!("Got an int bigger than five!"),
    Value(..) => println!("Got an int!"),
    Missing   => println!("No such luck."),
}
</pre>

7、指针也可以玩。

<pre>let x = &5i;

match x {
    &x => println!("Got a value: {}", x),
}
</pre>

8、可以用ref来创建一个引用。

<pre>let x = &5i;

match x {
    &x => println!("Got a value: {}", x),
}
</pre>

<pre>let mut x = 5i;

match x {
    ref mut x => println!("Got a mutable reference to {}", x),
}
</pre>

9、可以解构结构体。

<pre>struct Point {
    x: int,
    y: int,
}

let origin = Point { x: 0i, y: 0i };

match origin {
    Point { x: x, y: y } => println!("({},{})", x, y),
}
</pre>

10、可以部分匹配结构体。

<pre>struct Point {
    x: int,
    y: int,
}

let origin = Point { x: 0i, y: 0i };

match origin {
    Point { x: x, .. } => println!("x is {}", x),
}
</pre>

11、以上的玩法都可以结合起来玩。

<pre>match x {
    Foo { x: Some(ref name), y: None } => ...
}
</pre>

12、模式匹配确实很强大，可以大幅减少代码量。